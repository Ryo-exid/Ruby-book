# 正規表現入門その4  https://qiita.com/jnchito/items/b0839f4f4651c29da408

=begin


\b というメタ文字
「単語の境界」を表す。（位置を示すので アンカー の一種です）
単語の境界とはスペースだったり、ピリオドだったり、ダブルクオートだったり、行頭や行末だったり、様々。

きれいに "ear" だけを抜き出す
\bear\b



ファイル名だけをピタリと抜き出す（肯定の後読み）
filename=([^;]+)


(?<=abc) のように書くと "abc" という文字列そのものではなく、その文字列の「直後の位置」（abc であれば c の直後）にマッチ
これを （肯定の）後読み と言う。


(?<=filename=)[^;]+

「"filename=" という文字列の直後から始まって、";" 以外の文字が1文字以上続く」という意味



=end


text = <<-TEXT
type=zip; filename=users.zip; size=1024;
type=xml; filename=posts.xml; size=2048;
TEXT
p a = text.scan(/(?<=filename=)[^;]+/) #=> ["users.zip", "posts.xml"]


puts '①---------------------------'


=begin


肯定の先読み

(?=abc) のように書くと "abc" という文字列そのものではなく、その文字列の「直前の位置」（abc であれば a の直前）にマッチ
これを （肯定の）先読み と言う


\w+(?=:bass)

「":bass" という文字列の直前にある、1文字以上続く英単語の構成文字」という意味


=end


text = <<-TEXT
John:guitar, George:guitar, Paul:bass, Ringo:drum
Freddie:vocal, Brian:guitar, John:bass, Roger:drum
TEXT
p a = text.scan(/\w+(?=:bass)/) #=> ["Paul", "John"]


=begin

否定の後読み

(?<!abc) のように書くと "abc" という文字列 以外 の「直後の位置」にマッチ
これを 否定の後読み と言う



否定の先読み

(?!abc) のように書くと "abc" という文字列 以外 の「直前の位置」にマッチ
これを 否定の先読み と言う



URLがそのまま画面上に表示されているリンクを見つける（後方参照）

--------------------------------------------------------
<a href="http://google.com">http://google.com</a>
<a href="http://yahoo.co.jp">ヤフー</a>
<a href="http://facebook.com">http://facebook.com</a>
--------------------------------------------------------

「URLがそのまま画面上に表示されているリンク（1行目と3行目）」を検索

<a href="(.+?)">\1<\/a>

\1は「( ) でキャプチャされた1番目の文字列」を表している
つまり、(.+?) と \1 は同じ文字列を指すことになる



数秒、数分、数時間のケース
この場合は「数字 + s/m/h」というパターンになっているので正規表現で書きやすいです。

 (\d+[smh])



 1日以上前の場合は「アルファベット3文字 + 数字」というパターン

 (\w{3} \d+)



 (_+|\w+)*a のように、+ や * が ( ) の中にも外にも出てくる正規表現は危険。
こういう正規表現は内部的な組み合わせの数が爆発的に増え、とんでもなく遅くなることが多い。



"users[100]" や "users[123]" という文字列があり、"[100]" や "[123]" の部分だけマッチさせたい場合は \[\d+\] と書く。

[ ] はそのまま使うとメタ文字になるが、\[ \] とバックスラッシュでエスケープすると、純粋に "[ ]" という文字にマッチするようになる。



 "user.rb" や "base.css" のような拡張子付きのファイル名を検索するとき

 \w+\.\w{1,3} のようにピリオドを忘れずにエスケープする！


[()$.*+?|{}] と書くと、「"(" か ")" か "$" か・・・ "}" のいずれか1文字」の意味になる。



go{4,}gle という正規表現を入力すると、「"o" が4文字以上」の場合にマッチ

go{,3}gle を入力すると、「"o" が3文字以下」の場合にマッチ



\W、\D、\S、\B が存在

\W = 英単語の構成文字以外（記号や空白文字など）
\D = 半角数字以外
\S = 空白文字以外
\B = 単語の境界以外の位置




\b は単語の境界を表す
(?=abc) は「abcという文字列の直前の位置」を表す（先読み）
(?<=abc) 「abcという文字列の直後の位置」を表す（後読み）
(?!abc) は「abcという文字列以外の直前の位置」を表す（否定の先読み）
(?<!abc) 「abcという文字列以外の直後の位置」を表す（否定の後読み）
キャプチャした文字列は正規表現内でも \1 や \2 といった連番で参照できる（後方参照）
? や *、+ といった量指定子は ( ) の後ろに付けることもできる
| を使ったOR条件では、各条件内でもメタ文字が使える
書き方によっては、とんでもなく遅い正規表現ができあがることもある
メタ文字はバックスラッシュ（\）でエスケープする
[ ] 内ではメタ文字の種類や使われる位置によって各文字の働きが異なる
{n,} や {,n} はそれぞれ「直前の文字がn個以上」「n個以下」の意味になる
\W、\S、\D、\B はそれぞれ \w、\s、\d、\b の逆の意味になる


=end